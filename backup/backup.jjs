// Simple incremental backup script which uses hardlinks to last backup if files are unchanged

// Script starting here
// imports
var JLong = Java.type('java.lang.Long');
var JLongArray = Java.type('long[]');
var JString = Java.type('java.lang.String');
var Thread = Java.type('java.lang.Thread');
var System = Java.type('java.lang.System');

var Arrays = Java.type('java.util.Arrays');
var ArrayList = Java.type('java.util.ArrayList');
var HashMap = Java.type('java.util.HashMap');
var Collections = Java.type('java.util.Collections');

var Stream = Java.type('java.util.stream.Stream');
var Collectors = Java.type('java.util.stream.Collectors');

var ConcurrentHashMap = Java.type('java.util.concurrent.ConcurrentHashMap');
var AtomicLong = Java.type('java.util.concurrent.atomic.AtomicLong');
var Executors = Java.type('java.util.concurrent.Executors');
var Callable = Java.type('java.util.concurrent.Callable');

var LocalDateTime = Java.type('java.time.LocalDateTime');
var DateTimeFormatter = Java.type('java.time.format.DateTimeFormatter');

var Files = Java.type('java.nio.file.Files');
var Paths = Java.type('java.nio.file.Paths');
var SimpleFileVisitor = Java.type('java.nio.file.SimpleFileVisitor');
var FileVisitResult = Java.type('java.nio.file.FileVisitResult');
var StandardCopyOption = Java.type('java.nio.file.StandardCopyOption');
var FileTime = Java.type('java.nio.file.attribute.FileTime');

// globals
var config = JSON.parse(new JString(Files.readAllBytes(Paths.get('backup-config.json'))));
var today = LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE);

var readSize = 10000;
var writeSize = 10000;

/**
* Formatted Commandline output.
*/
var out = System.out;
function printf(messageFormat) {
	var ts = LocalDateTime.now().withNano(0).format(DateTimeFormatter.ISO_LOCAL_TIME);
	var msg = ts + ' ' + messageFormat;
	if (arguments.length > 1){
		msg = JString.format(msg, Array.prototype.slice.call(arguments, 1));
	}
	out.println(msg);
}

/**
* A file entry found in step 1 in the source or last folder
*/
var EMPTY_DIR_ATTRIBUTES = new JLongArray(3);
var Entry = function(file, attrs, target){
	this.file = file;

	// attributes
	this.directory = attrs.isDirectory();
	if (this.directory){
		this.attributes = EMPTY_DIR_ATTRIBUTES;
	} else {
		var a = new JLongArray(3);
		a[0] = attrs.size();
		a[1] = attrs.creationTime().toMillis();
		a[2] = attrs.lastModifiedTime().toMillis();
		this.attributes = a;
	}
	
	// set target if defined
	if (target) {		
		this.target = target;
	}
}
Entry.prototype.size = function() {
	return this.attributes[0];
}
/**
* Check if the other entry has the same attributes as this one
*/
Entry.prototype.hasEqualAttributes = function(other) {
	// printf('%s: %s = %s', this.file, Arrays.toString(this.attributes), Arrays.toString(other.attributes));
	return Arrays.equals(this.attributes, other.attributes);
}
/**
* Copies to the target.
*/
Entry.prototype.copy = function(){
	Files.copy(this.file, this.target, StandardCopyOption.COPY_ATTRIBUTES);
	if (this.directory){		
		return;
	}
	// the creation time is not automatically copied on windows (ntfs) for regular files
	// (no problem with directories, which is a bit strange)
	var creationTime = FileTime.fromMillis(this.attributes[1]);
	Files.setAttribute(this.target, 'creationTime', creationTime);
	// var result = Files.getAttribute(this.target, 'creationTime');
	// printf('%s: set creationTime to %s. Result: %s', this.file, creationTime, result);
}
Entry.prototype.createLink = function(targetFile){
	// printf('Create link: %s -> %s', this.target, targetFile);
	Files.createLink(this.target, targetFile);
}

var ONE_MB = 1024 * 1024;
function toMb(bytes){
	return (bytes / ONE_MB) | 0;
}

/**
* Wraps all functions in Callables, submits them to the threadpool and waits for their completion
*/
function runParallel(executorService, functionStream, resultFunction){
	functionStream
		.map(function(f) executorService.submit(new Callable(f)))
		.collect(Collectors.toList())
		.forEach(function (f) {
			try {
				var result = f.get();
				if (resultFunction){
					resultFunction(result);
				}
			} catch (ex) {
				ex.printStackTrace();
			}
		});
}


// the target dir to write to
var targetDir = Paths.get(config.target, today);
Files.createDirectories(targetDir);

// the dir of the last directory
var lastDir = Paths.get(config.target, 'last');
var canLink = config.incremental && Files.isDirectory(lastDir); 

// tracks which parent dirs do not yet exist (for next step)
var parentDirs = Collections.newSetFromMap(new ConcurrentHashMap());
function readSourceDirectory(source, updateFunction){
	// the list of files (the result)
	var files = new ArrayList();
	var sTargetDir = targetDir.resolve(source.getFileName());

	var Visitor = Java.extend(SimpleFileVisitor, {
		preVisitDirectory: function(dir, attrs){
			var target = sTargetDir.resolve(source.relativize(dir));
			var e = new Entry(dir, attrs, target);
			files.add(e);
			parentDirs.add(dir);
			updateFunction(e);
			return FileVisitResult.CONTINUE;
		},
		
		visitFile: function(file, attrs){
			var target = sTargetDir.resolve(source.relativize(file));
			var e = new Entry(file, attrs, target);
			files.add(e);
			updateFunction(e);
			return FileVisitResult.CONTINUE;
		}
	});
	Files.walkFileTree(source, new Visitor());
	return files;
}

// a map of the files of the last backup for comparisons
var lastIndex = new ConcurrentHashMap();
function readLastDirectory(source){
	var sLastDir = lastDir.resolve(source.getFileName());
	var Visitor = Java.extend(SimpleFileVisitor, {
		visitFile: function(file, attrs){
			var sourceFile = source.resolve(sLastDir.relativize(file));
			lastIndex.put(sourceFile, new Entry(file, attrs));
			return FileVisitResult.CONTINUE;
		}
	});
	Files.walkFileTree(sLastDir, new Visitor());
	return null;
}

/**
* First waits for the existence of the parent dir, then copies either the file or the directory (without contents)
*/
function createFile(entry){
	// wait until the parent dir exists (-> is no longer in the dir index)
	var parent = entry.file.getParent();
	while (parentDirs.contains(parent)){
		Thread.sleep(1);
	}
	
	// create dir or file
	if (entry.directory){
		// Creates the dir with the original attributes, but not its contents
		entry.copy();	
		// Do not longer track parentDir as nonexistant
		parentDirs.remove(entry.file);
		return;
	}
	
	// regular file: check if an identical backup exists. if so, then create a hardlink
	var last = lastIndex.get(entry.file);
	if (last && entry.hasEqualAttributes(last)){			
		// Attributes are identical - create Link
		entry.createLink(last.file);
		return;
	}
	
 	// Not identical or nonexistant? create a copy
	entry.copy();
}


// Do stuff!
var threadpool = Executors.newFixedThreadPool(Math.max(1, config.parallelism));
try {
	printf('Check files and dirs for backup...');
	
	var size = new AtomicLong();
	var count = new AtomicLong();
	var readCounter = function(entry) {
		var sz = size.addAndGet(entry.size());
		var pos = count.incrementAndGet();
		if (pos % readSize === 0){
			printf('%6d files read (%6d MB)', pos, toMb(sz));
		}
	}
	
	var files = new ArrayList();
	runParallel(threadpool, Arrays.asList(config.sources).stream().flatMap(function(sourcePath) {
			var source = Paths.get(sourcePath);			
			var s = Stream.builder();
			s.add(function() readSourceDirectory(source, readCounter));						
			if (canLink){
				s.add(function() readLastDirectory(source));
			}
			return s.build();
	}), function(result){
		if (result){
			files.addAll(result);
		}
	});
	
	var byteSizeInMb = toMb(size.get());
	
	printf('Create %s files and directories (%d MB)...', files.size(), byteSizeInMb);
	size.set(0);
	count.set(0);
	var writeCounter = function(entry){
		var sz = size.addAndGet(entry.size());
		var pos = count.incrementAndGet();
		if (pos % writeSize === 0){
			printf('%10d / %10d files created (%6d / %6d MB)', pos, files.size(), toMb(sz), byteSizeInMb);
		}
	}
	runParallel(threadpool, files.stream().map(function(entry){
		return function() {
			createFile(entry);
			writeCounter(entry);
		}
	}));
	
} finally {
	threadpool.shutdown();
}
	
printf('Set last to new dir: %s -> %s', lastDir, targetDir);
Files.deleteIfExists(lastDir);
Files.createSymbolicLink(lastDir, targetDir);
printf('Backup finished');
