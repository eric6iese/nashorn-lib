// Simple incremental backup script which uses hardlinks to last backup if files are unchanged

// Script starting here
// imports
var JLong = Java.type('java.lang.Long');
var JLongArray = Java.type('long[]');
var JString = Java.type('java.lang.String');
var Thread = Java.type('java.lang.Thread');
var System = Java.type('java.lang.System');

var Objects = Java.type('java.util.Objects');
var Arrays = Java.type('java.util.Arrays');
var List = Java.type('java.util.List');
var Map = Java.type('java.util.Map');
var ArrayList = Java.type('java.util.ArrayList');
var HashMap = Java.type('java.util.HashMap');
var SimpleEntry = Java.type('java.util.AbstractMap.SimpleEntry');
var Collections = Java.type('java.util.Collections');

var Stream = Java.type('java.util.stream.Stream');
var DoubleStream = Java.type('java.util.stream.DoubleStream');
var Collectors = Java.type('java.util.stream.Collectors');

var ConcurrentHashMap = Java.type('java.util.concurrent.ConcurrentHashMap');
var AtomicLong = Java.type('java.util.concurrent.atomic.AtomicLong');
var Executors = Java.type('java.util.concurrent.Executors');
var Callable = Java.type('java.util.concurrent.Callable');
var CompletableFuture = Java.type('java.util.concurrent.CompletableFuture');

var LocalDateTime = Java.type('java.time.LocalDateTime');
var DateTimeFormatter = Java.type('java.time.format.DateTimeFormatter');

var File = Java.type('java.io.File');
var Files = Java.type('java.nio.file.Files');
var Paths = Java.type('java.nio.file.Paths');
var SimpleFileVisitor = Java.type('java.nio.file.SimpleFileVisitor');
var FileVisitResult = Java.type('java.nio.file.FileVisitResult');
var StandardCopyOption = Java.type('java.nio.file.StandardCopyOption');
var FileTime = Java.type('java.nio.file.attribute.FileTime');
var AccessDeniedException = Java.type('java.nio.file.AccessDeniedException');

// globals
var config = JSON.parse(new JString(Files.readAllBytes(Paths.get('backup-config.json'))));
var today = LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE);

// global dirs
var targetDir = Paths.get(config.target, today);
var lastDir = Paths.get(config.target, 'last');

var readSize = 10000;
var writeSize = 1000;

var ONE_MB = 1024 * 1024;
function toMb(bytes){
	return (bytes / ONE_MB) | 0;
}

/**
* A formatted amount of time.
*/
function formatTime(millis){
	var seconds = millis / 1000;
	var hours = Math.min(99, seconds / 3600);
	seconds %= 3600;
	var minutes = seconds / 60;
	seconds %= 60;
	return JString.format('%02d:%02d:%02d', hours|0, minutes|0, seconds|0);
}

var out = System.out;
/**
* Formatted Commandline output.
*/
function printf(messageFormat) {
	var msg = LocalDateTime.now().withNano(0).format(DateTimeFormatter.ISO_TIME) + ' ' + messageFormat;
	if (arguments.length > 1) {
		msg = JString.format(msg, Array.prototype.slice.call(arguments, 1));
	}
	out.println(msg);
}

/**
* This refers to the current processing environment.
* Each source root is processed independently.
*/
var Source = {	
	path: null,
	target: null,
	last: null,
};


var DIR_ATTRIBUTES = new JLongArray(3);
DIR_ATTRIBUTES[0] = 1;
var LINK_ATTRIBUTES = new JLongArray(3);
LINK_ATTRIBUTES[0] = 1;

/**
* Wrapper functions to handle the Entry as a memory-efficient pseudo-object based on an internal java structures.
* This is needed as we will create a lot of these entries - Millions for large backups.
*/
var Entry = {

	/**
	* Creates a file entry found in step 1 in the source or last folder.
	*/
	create: function (file, attrs, target) {
		return new SimpleEntry(file.toString(), Entry.createAttributes(attrs));
	},
	
	/**
	* Creates the attributes out of BasicFileAttributes.
	*/
	createAttributes: function(attrs) {
		var dir = attrs.isDirectory();
		if (dir){
			return DIR_ATTRIBUTES;
		}
		var a = new JLongArray(3);
		a[0] = attrs.size();
		a[1] = attrs.creationTime().toMillis();
		a[2] = attrs.lastModifiedTime().toMillis();
		return a;
	},

	file: function(entry) entry.key,
	source: function(entry) Source.path.resolve(entry.key),
	target: function(entry) Source.target.resolve(entry.key),
	last: function(entry) Source.last.resolve(entry.key),
	
	isDirectory: function(entry) entry.value === DIR_ATTRIBUTES,
	size: function(entry) entry.value[0],

	/**
	* Check if the other entry has the same attributes as this one.
	* If so, then the copy step will create a link.
	*/	
	updateAttributes: function(entry, otherAttributes) {
		var attributes = entry.value;
		// printf('%s: %s = %s', entry.key, Arrays.toString(attributes), Arrays.toString(otherAttributes));
		
		// if the file is identical, the link attributes whill be used:
		// - then link will be created
		// - otherwise a normal copy occurs (as in dirs)
		if (Arrays.equals(attributes, otherAttributes)){
			entry.value = LINK_ATTRIBUTES;
		}
	},
	
	/**
	* Copies to the target, or links it if checkAttributes had a different result
	*/
	copy: function(entry){
		var attributes = entry.value;
		
		var target = Entry.target(entry);
		if (attributes === LINK_ATTRIBUTES) {
			var last = Entry.last(entry);
			// printf('Create link: %s -> %s', target, last);
			Files.createLink(target, last);
			return;
		} 
		// Copy the file or dir with all attributes
		// DirContents are NOT copied by this method
		var src = Entry.source(entry);
		// printf('Copy: %s -> %s', src, target);
		Files.copy(src, target, StandardCopyOption.COPY_ATTRIBUTES);		
		
		// the creation time is not automatically copied on windows (ntfs) for regular files
		// (no problem with directories, which is a bit strange)
		if (attributes === DIR_ATTRIBUTES) {
			return;
		}
		var creationTime = FileTime.fromMillis(attributes[1]);
		Files.setAttribute(target, 'creationTime', creationTime);
		// var result = Files.getAttribute(target, 'creationTime');
		// printf('%s: set creationTime to %s. Result: %s', target, creationTime, result);	
	}
}

/**
* Wraps all functions in Callables, submits them to the threadpool and waits for their completion
*/
var threadpool = null;
function runParallel(functionList, resultFunction){
	functionList.replaceAll(function(f) threadpool.submit(new Callable(f)));
	functionList.replaceAll(function (f) {
		try {
			var result = f.get();
			if (resultFunction){
				resultFunction(result);
			}
		} catch (ex) {
			ex.printStackTrace();
		}
		return null;
	});
}

// the target dir to write to
Files.createDirectories(targetDir);

// If any of the file walks fails, the corresponding exceptions are handled here
function visitFileFailed(file, ioe){
	if (ioe instanceof AccessDeniedException){
		printf('Skip file %s (not accessible)', file);
	} else {
		ioe.printStackTrace();
	}
	return FileVisitResult.CONTINUE;
}

// tracks which parent dirs do not yet exist (for next step)
var parentDirs = Collections.newSetFromMap(new ConcurrentHashMap());
function readSourceDirectory(baseDir, updateFunction){
	parentDirs.clear();
	
	// the list of files (the result)
	var first = true;
	var files = new ArrayList();
	var SourceVisitor = Java.extend(SimpleFileVisitor, {
		
		preVisitDirectory: function(dir, attrs){
			// Skip first entry (root dir)
			if (first){
				first = false;
				return FileVisitResult.CONTINUE;
			}
			var entry = Entry.create(baseDir.relativize(dir), attrs);
			parentDirs.add(Entry.file(entry));
			files.add(entry);
			updateFunction(entry);
			return FileVisitResult.CONTINUE;
		},
		
		visitFile: function(file, attrs){
			if (attrs.isOther()){
				printf('Skip file %s (special file)', file);
				return FileVisitResult.CONTINUE;
			}
			var entry = Entry.create(baseDir.relativize(file), attrs);
			files.add(entry);
			updateFunction(entry);
			return FileVisitResult.CONTINUE;
		},
		
		visitFileFailed: visitFileFailed
	});
	Files.walkFileTree(baseDir, new SourceVisitor());
	return files;
}

// reads all files created in the last backup, if any
function readLastDirectory(baseDir){
	if (!config.incremental || !Files.isDirectory(baseDir)){
		return null;
	}
	// a map of the files of the last backup for comparisons
	var lastIndex = new HashMap();
	var LastVisitor = Java.extend(SimpleFileVisitor, {
		
		visitFile: function(file, attrs){
			if (attrs.isOther()){
				printf('Skip file %s (special file)', file);
				return FileVisitResult.CONTINUE;
			} 
			lastIndex.put(baseDir.relativize(file).toString(), Entry.createAttributes(attrs));
			return FileVisitResult.CONTINUE;
		},
		
		visitFileFailed: visitFileFailed
	});
	Files.walkFileTree(baseDir, new LastVisitor());
	return lastIndex;
}

/**
* First waits for the existence of the parent dir, then copies either the file or the directory (without content)
*/
function createFile(entry){
	var file = Entry.file(entry);
	if (!file.isEmpty()){
		var parent = Objects.toString(new File(file).getParent(), '');
		// printf("%s, parent: %s", file, parent);
		// wait until the parent dir exists (-> is no longer in the dir index)
		while (parentDirs.contains(parent)){
			Thread.sleep(1);
		}
	}
	
	// create or link the file / dir
	Entry.copy(entry);	
	
	// if this was a dir, then track it no longer
	if (Entry.isDirectory(entry)){	
		// Do not longer track parentDir as nonexistant
		parentDirs.remove(file);
	}
}



function processSource(sourceDir){
	sourceDir = Paths.get(sourceDir);
	// In the case of a filesystem root, a root alias is used
	var sourceIsRoot = sourceDir.getRoot().equals(sourceDir);
	var sourceName;
	if (sourceIsRoot) {
		sourceName = sourceDir.toString().replaceAll('[:/\\\\]', '');
		if (sourceName.isEmpty()){
			sourceName = 'ROOT';
		}
	} else {
		sourceName = sourceDir.getFileName();
	}
	Source.path = sourceDir;
	Source.target = targetDir.resolve(sourceName);
	Source.last = lastDir.resolve(sourceName);
	
	printf('Create backup from %s %s to %s', sourceIsRoot ? 'filesystem' : 'directory', sourceDir, Source.target);
	
	printf('%s: Check files and dirs for backup...', sourceName);
	var size = new AtomicLong();
	var count = new AtomicLong();
	var readCounter = function(entry) {
		var sz = size.addAndGet(Entry.size(entry));
		var pos = count.incrementAndGet();
		if (pos % readSize === 0){
			printf('%6d files read (%6d MB)', pos, toMb(sz));
		}
	}
	
	// prepare tasks
	var readTasks = Arrays.asList(
		function() readSourceDirectory(sourceDir, readCounter),
		function() readLastDirectory(Source.last)
	);
	var writeTasks = null;
	var lastIndex = null;
	runParallel(readTasks, function(result){
		if (result instanceof List){
			writeTasks = result;
		} else if (result instanceof Map){
			lastIndex = result;
		}
	});
	
	var byteSize = size.get();
	var byteSizeInMb = toMb(byteSize);
	var filesSize = writeTasks.size();
	printf('%6d files read (%6d MB)', filesSize, byteSizeInMb);
	
	// evaluate lastIndex
	if (lastIndex){
		size.set(0);
		writeTasks.parallelStream().forEach(function(entry){
			if (Entry.isDirectory(entry)){
				return;
			}
			// regular file: check if an identical backup exists.
			// if so, then copy will create a hardlink
			var last = lastIndex.get(Entry.file(entry));
			if (last !== null) {
				Entry.updateAttributes(entry, last);
			}
			size.addAndGet(Entry.size(entry));
		});
		// lastIndex can be gc'ed
		lastIndex = null;
		var oldSize = byteSizeInMb;
		byteSize = size.get();
		byteSizeInMb = toMb(byteSize);
		printf('Some of the files will be hardlinked instead of copied (%d -> %d MB) from %s', oldSize, byteSizeInMb, Source.last);
	}
	
	printf('%s: Create %s files and directories (%d MB) in %s...', sourceName, filesSize, byteSizeInMb, Source.target);
	
	// create base target dir
	if (sourceIsRoot){
		// Cannot copy an fs-root, just create a new directory
		Files.createDirectory(Source.target);
	} else {
		// Copy the dir with attributes (but not contents)
		Files.copy(sourceDir, Source.target, StandardCopyOption.COPY_ATTRIBUTES);
	}
	
	// System.gc();
	// System.console().readLine('Hit enter to continue');
	size.set(0);
	count.set(0);
	var startTime = System.currentTimeMillis();
	var writeCounter = function(entry){
		var sz = size.addAndGet(Entry.size(entry));
		var pos = count.incrementAndGet();
		if (pos % writeSize === 0){
			var timeTaken = System.currentTimeMillis() - startTime;
			var timeBySize = (byteSize / sz) * timeTaken;
			var timeByFiles = (filesSize / pos) * timeTaken;
			var timeEstimate = DoubleStream.of(timeBySize, timeByFiles).average().getAsDouble();
			var timeRemaining = timeEstimate - timeTaken;
			printf('%10d / %10d files created (%6d / %6d MB). Time: %s / %s. Remaining: %s', pos, filesSize, toMb(sz), byteSizeInMb, formatTime(timeTaken), formatTime(timeEstimate), formatTime(timeRemaining));
		}
	}
	
	writeTasks.replaceAll(function(entry){
		return function() {
			createFile(entry);
			writeCounter(entry);
		}
	});
	runParallel(writeTasks);
	printf('%10d / %10d files created (%6d / %6d MB).', count.get(), filesSize, toMb(size.get()), byteSizeInMb);
	printf('%s: Done.', sourceDir);
}

// Start the threadpool and do stuff!
threadpool = Executors.newFixedThreadPool(Math.max(1, config.parallelism));
try {
	config.sources.forEach(processSource);
} finally {
	threadpool.shutdown();
}
	
printf('Set last to new dir: %s -> %s', lastDir, targetDir);
Files.deleteIfExists(lastDir);
Files.createSymbolicLink(lastDir, targetDir);
printf('Backup finished');