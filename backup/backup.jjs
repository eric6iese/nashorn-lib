// Simple incremental backup script which uses hardlinks to last backup if files are unchanged

// Script starting here
// imports
var JLong = Java.type('java.lang.Long');
var JLongArray = Java.type('long[]');
var JString = Java.type('java.lang.String');
var Thread = Java.type('java.lang.Thread');
var System = Java.type('java.lang.System');


var Arrays = Java.type('java.util.Arrays');
var ArrayList = Java.type('java.util.ArrayList');
var HashMap = Java.type('java.util.HashMap');
var Collections = Java.type('java.util.Collections');
var Collectors = Java.type('java.util.stream.Collectors');

var AtomicLong = Java.type('java.util.concurrent.atomic.AtomicLong');
var Executors = Java.type('java.util.concurrent.Executors');
var Callable = Java.type('java.util.concurrent.Callable');

var LocalDateTime = Java.type('java.time.LocalDateTime');
var DateTimeFormatter = Java.type('java.time.format.DateTimeFormatter');
var Files = Java.type('java.nio.file.Files');
var Paths = Java.type('java.nio.file.Paths');
var SimpleFileVisitor = Java.type('java.nio.file.SimpleFileVisitor');
var FileVisitResult = Java.type('java.nio.file.FileVisitResult');
var FileTime = Java.type('java.nio.file.attribute.FileTime');
var BasicFileAttributes = Java.type('java.nio.file.attribute.BasicFileAttributes');
var StandardCopyOption = Java.type('java.nio.file.StandardCopyOption');

// globals
var config = JSON.parse(new JString(Files.readAllBytes(Paths.get('backup-config.json'))));
var today = LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE);
 today = "20170511"
var readSize = 10000;
var writeSize = 10000;

/**
* A found entry in step 1 in the source or last folder
*/
var Entry = function(file, to, attrs){
	this.file = file;
	this.to = to;
	
	var a = null;
	if (attrs){
		a = new JLongArray(2);
		a[0] = attrs.size();
		a[1] = attrs.lastModifiedTime().toMillis();		
	}
	
	this.attributes = a;
}


var ONE_MB = 1024 * 1024;
function toMb(bytes){
	return (bytes / ONE_MB) | 0;
}

/**
* Formatted Commandline output.
*/
function printf(messageFormat, args) {
	var ts = LocalDateTime.now().withNano(0).format(DateTimeFormatter.ISO_LOCAL_TIME);
	if (args === undefined){
		System.out.println(ts + ' ' + messageFormat);
	} else {
		System.out.println(ts + ' ' + JString.format(messageFormat, args));
	}
}

// target folders
var targetDir = Paths.get(config.target, today);
var lastDir = Paths.get(config.target, 'last');

Files.createDirectories(targetDir);

var canLink = config.incremental && Files.isDirectory(lastDir); 

var threadpool = Executors.newFixedThreadPool(config.parallelism);

/**
* Wraps all functions in Callables, submits them to the threadpool and waits for their completion
*/
function runParallel(functionStream){
	functionStream
		.map(function(f) threadpool.submit(new Callable(f)))
		.collect(Collectors.toList())
		.forEach(function (f) f.get());	
}

printf('Calculating files and dirs for backup... ');
var counter = new AtomicLong();
var fullSize = 0;
var dirs = new ArrayList();
var files = new ArrayList();
var lastIndex = new HashMap();
config.sources.forEach(function(sourcePath){
	var source = Paths.get(sourcePath);
	var s = source.getFileName();
	var sLastDir = lastDir.resolve(s);
	var sTargetDir = targetDir.resolve(s);
	
	var Visitor = Java.extend(SimpleFileVisitor, {
		preVisitDirectory: function(dir, attrs){
			var from = source.relativize(dir);
			var to = sTargetDir.resolve(from);
			dirs.add(new Entry(dir, to, null));
			return FileVisitResult.CONTINUE;
		},
		
		visitFile: function(file, attrs){
			var from = source.relativize(file);
			var to = sTargetDir.resolve(from);
			var e = new Entry(file, to, attrs);
			files.add(e);
			fullSize += e.attributes[0];
			var pos = counter.incrementAndGet();
			if (pos % readSize === 0){
				printf('%6d files read (%6dmb)', [pos, toMb(fullSize)]);
			}
			return FileVisitResult.CONTINUE;			
		}
	});

	var LinkVisitor = Java.extend(SimpleFileVisitor, {
		visitFile: function(file, attrs){
			var from = source.resolve(sLastDir.relativize(file));
			lastIndex.put(from, new Entry(file, null, attrs));
			return FileVisitResult.CONTINUE;
		}
	});
	
	var tasks = new ArrayList();
	tasks.add(function() Files.walkFileTree(source, new Visitor()));
	
	if (canLink){
		tasks.add(function() Files.walkFileTree(sLastDir, new LinkVisitor()));		
	}
	
	runParallel(tasks.stream());
});

var dirsSize = dirs.size();
var filesSize = files.size();

printf(dirsSize + ' directories, ' + filesSize + ' files');

printf('Create directories..');
counter.set(0);

var dirMap = new HashMap();
dirs.forEach(function(e) dirMap.put(e.file, e));
dirMap = Collections.synchronizedMap(dirMap);
runParallel(dirs.stream().map(function(e){
	return function() {
		// wait until the parent dir exists (-> is no longer in the dir index)
		var parent = e.file.getParent();
		while (dirMap.containsKey(parent)){
			Thread.sleep(1);
		}
		
		// Copies the dir and its attributes, but not the contents
		Files.copy(e.file, e.to, StandardCopyOption.COPY_ATTRIBUTES);
		// Files.createDirectory(e.file);

		// Do not longer track dir
		dirMap.remove(e.file);
		
		var pos = counter.incrementAndGet();
		if (pos % writeSize === 0){
			printf('%6d / %6d directories created', [pos, dirsSize]);
		}
	};
}));

printf('Create files..');
var written = new AtomicLong();
counter.set(0);
runParallel(files.stream().map(function(e){
	return function(){
		var linked = false;
		var last = lastIndex.get(e.file);
		if (last) {
		
			// check if last entry is same as this one (very likely)
			// printf(e.file + ': ' + Arrays.toString(e.attributes) + ' = ' + Arrays.toString(last.attributes));
			
			if (Arrays.equals(e.attributes, last.attributes)){
				
				// Attributes are identical - create Link
				// printf('Create link to ' + last.file);
				Files.createLink(e.to, last.file);
				linked = true;
			}
		}
	

		if (!linked){
			// Not identical or nonexistant? create a copy
			Files.copy(e.file, e.to, StandardCopyOption.COPY_ATTRIBUTES);
		}
		
		var sz = written.addAndGet(e.attributes[0]);
		var pos = counter.incrementAndGet();
		if (pos % writeSize === 0){
			printf('%10d / %10d files created (%6d / %6d mb)', [pos, filesSize, toMb(sz), toMb(fullSize)]);
		}
		return null;
	};
}));

threadpool.shutdown();

printf('Set last to new dir: %s -> %s', [lastDir, targetDir]);
Files.deleteIfExists(lastDir);
Files.createSymbolicLink(lastDir, targetDir);
printf('Backup finished');