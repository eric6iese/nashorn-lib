// Simple incremental backup script which uses hardlinks to last backup if files are unchanged

// Script starting here
// imports
var JLong = Java.type('java.lang.Long');
var JLongArray = Java.type('long[]');
var JString = Java.type('java.lang.String');
var Thread = Java.type('java.lang.Thread');
var System = Java.type('java.lang.System');

var Arrays = Java.type('java.util.Arrays');
var ArrayList = Java.type('java.util.ArrayList');
var HashMap = Java.type('java.util.HashMap');
var Collections = Java.type('java.util.Collections');

var Stream = Java.type('java.util.stream.Stream');
var Collectors = Java.type('java.util.stream.Collectors');

var ConcurrentHashMap = Java.type('java.util.concurrent.ConcurrentHashMap');
var AtomicLong = Java.type('java.util.concurrent.atomic.AtomicLong');
var Executors = Java.type('java.util.concurrent.Executors');
var Callable = Java.type('java.util.concurrent.Callable');

var LocalDateTime = Java.type('java.time.LocalDateTime');
var DateTimeFormatter = Java.type('java.time.format.DateTimeFormatter');

var Files = Java.type('java.nio.file.Files');
var Paths = Java.type('java.nio.file.Paths');
var SimpleFileVisitor = Java.type('java.nio.file.SimpleFileVisitor');
var FileVisitResult = Java.type('java.nio.file.FileVisitResult');
var StandardCopyOption = Java.type('java.nio.file.StandardCopyOption');
var FileTime = Java.type('java.nio.file.attribute.FileTime');

// globals
var config = JSON.parse(new JString(Files.readAllBytes(Paths.get('backup-config.json'))));
var today = LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE);
 today = '20170511'

var readSize = 10000;
var writeSize = 10000;

/**
* Formatted Commandline output.
*/
var out = System.out;
function printf(messageFormat) {
	var ts = LocalDateTime.now().withNano(0).format(DateTimeFormatter.ISO_LOCAL_TIME);
	var msg = ts + ' ' + messageFormat;
	if (arguments.length > 1){
		msg = JString.format(msg, Array.prototype.slice.call(arguments, 1));
	}
	out.println(msg);
}

var EMPTY_DIR_ATTRIBUTES = new JLongArray(4);
var FileEntry = function(file, attrs, target){
	this.file = file;

	// attributes
	var dir = attrs.isDirectory();
	if (dir){
		this.attributes = EMPTY_DIR_ATTRIBUTES;
	} else {
		var a = new JLongArray(4);
		a[0] = 1;
		a[1] = attrs.size();
		a[2] = attrs.creationTime().toMillis();
		a[3] = attrs.lastModifiedTime().toMillis();
		this.attributes = a;
	}
	
	// set target if defined
	if (target) {		
		this.target = target;
	}
}
/**
* Wrapper functions to handle the Entry as a memory-efficient pseudo-object based on an internal java structure.
* This is needed as we will create a lot of these entries. Millions for large backups.
*/
var Entry = {

	/**
	* Creates a file entry found in step 1 in the source or last folder.
	*/
	create: function (file, attrs, target) {
		return new FileEntry(file, attrs, target);
	},

	file: function(entry) entry.file,

	isRegularFile: function(entry) (entry.attributes[0] & 1) === 1,
	
	isDirectory: function(entry) (entry.attributes[0] & 1) !== 1,
	
	size: function(entry) entry.attributes[1],

	/**
	* Check if the other entry has the same attributes as this one
	*/	
	hasEqualAttributes: function(entry, other) {
		// printf('%s: %s = %s', entry.file, Arrays.toString(entry.attributes), Arrays.toString(other.attributes));
		return Arrays.equals(entry.attributes, other.attributes);
	},
	
	/**
	* Copies to the target.
	*/
	copy: function(entry){
		Files.copy(entry.file, entry.target, StandardCopyOption.COPY_ATTRIBUTES);
		if (Entry.isDirectory(entry)){		
			return;
		}
		// the creation time is not automatically copied on windows (ntfs) for regular files
		// (no problem with directories, which is a bit strange)
		var creationTime = FileTime.fromMillis(entry.attributes[2]);
		Files.setAttribute(entry.target, 'creationTime', creationTime);
		// var result = Files.getAttribute(entry.target, 'creationTime');
		// printf('%s: set creationTime to %s. Result: %s', entry.file, creationTime, result);
	},
	
	createLink: function(entry, targetFile){
		// printf('Create link: %s -> %s', entry.target, targetFile);
		Files.createLink(entry.target, targetFile);
	}
}

var ONE_MB = 1024 * 1024;
function toMb(bytes){
	return (bytes / ONE_MB) | 0;
}

/**
* Wraps all functions in Callables, submits them to the threadpool and waits for their completion
*/
function runParallel(executorService, functionStream, resultFunction){
	functionStream
		.map(function(f) executorService.submit(new Callable(f)))
		.collect(Collectors.toList())
		.forEach(function (f) {
			try {
				var result = f.get();
				if (resultFunction){
					resultFunction(result);
				}
			} catch (ex) {
				ex.printStackTrace();
			}
		});
}


// the target dir to write to
var targetDir = Paths.get(config.target, today);
Files.createDirectories(targetDir);

// the dir of the last directory
var lastDir = Paths.get(config.target, 'last');
var canLink = config.incremental && Files.isDirectory(lastDir); 

// tracks which parent dirs do not yet exist (for next step)
var parentDirs = Collections.newSetFromMap(new ConcurrentHashMap());
function readSourceDirectory(source, updateFunction){
	// the list of files (the result)
	var files = new ArrayList();
	var sTargetDir = targetDir.resolve(source.getFileName());

	var Visitor = Java.extend(SimpleFileVisitor, {
		preVisitDirectory: function(dir, attrs){
			var target = sTargetDir.resolve(source.relativize(dir));
			var entry = Entry.create(dir, attrs, target);
			files.add(entry);
			parentDirs.add(dir);
			updateFunction(entry);
			return FileVisitResult.CONTINUE;
		},
		
		visitFile: function(file, attrs){
			var target = sTargetDir.resolve(source.relativize(file));
			var entry = Entry.create(file, attrs, target);
			files.add(entry);
			updateFunction(entry);
			return FileVisitResult.CONTINUE;
		}
	});
	Files.walkFileTree(source, new Visitor());
	return files;
}

// a map of the files of the last backup for comparisons
var lastIndex = new ConcurrentHashMap();
function readLastDirectory(source){
	var sLastDir = lastDir.resolve(source.getFileName());
	var Visitor = Java.extend(SimpleFileVisitor, {
		visitFile: function(file, attrs){
			var sourceFile = source.resolve(sLastDir.relativize(file));
			lastIndex.put(sourceFile, Entry.create(file, attrs));
			return FileVisitResult.CONTINUE;
		}
	});
	Files.walkFileTree(sLastDir, new Visitor());
	return null;
}

/**
* First waits for the existence of the parent dir, then copies either the file or the directory (without contents)
*/
function createFile(entry){
	// wait until the parent dir exists (-> is no longer in the dir index)
	var parent = Entry.file(entry).getParent();
	while (parentDirs.contains(parent)){
		Thread.sleep(1);
	}
	
	// create dir or file
	if (Entry.isDirectory(entry)){
		// Creates the dir with the original attributes, but not its contents
		Entry.copy(entry);	
		// Do not longer track parentDir as nonexistant
		parentDirs.remove(Entry.file(entry));
		return;
	}
	
	// regular file: check if an identical backup exists. if so, then create a hardlink
	var last = lastIndex.get(Entry.file(entry));
	if (last && Entry.hasEqualAttributes(entry, last)){			
		// Attributes are identical - create Link
		Entry.createLink(entry, last.file);
		return;
	}
	
 	// Not identical or nonexistant? create a copy
	Entry.copy(entry);
}


// Do stuff!
var threadpool = Executors.newFixedThreadPool(Math.max(1, config.parallelism));
try {
	printf('Check files and dirs for backup...');
	
	var size = new AtomicLong();
	var count = new AtomicLong();
	var readCounter = function(entry) {
		var sz = size.addAndGet(Entry.size(entry));
		var pos = count.incrementAndGet();
		if (pos % readSize === 0){
			printf('%6d files read (%6d MB)', pos, toMb(sz));
		}
	}
	
	var files = new ArrayList();
	runParallel(threadpool, Arrays.asList(config.sources).stream().flatMap(function(sourcePath) {
			var source = Paths.get(sourcePath);			
			var s = Stream.builder();
			s.add(function() readSourceDirectory(source, readCounter));						
			if (canLink){
				s.add(function() readLastDirectory(source));
			}
			return s.build();
	}), function(result){
		if (result){
			files.addAll(result);
		}
	});
	
	var byteSizeInMb = toMb(size.get());
	
	printf('Create %s files and directories (%d MB)...', files.size(), byteSizeInMb);
	size.set(0);
	count.set(0);
	var writeCounter = function(entry){
		var sz = size.addAndGet(Entry.size(entry));
		var pos = count.incrementAndGet();
		if (pos % writeSize === 0){
			printf('%10d / %10d files created (%6d / %6d MB)', pos, files.size(), toMb(sz), byteSizeInMb);
		}
	}
	runParallel(threadpool, files.stream().map(function(entry){
		return function() {
			createFile(entry);
			writeCounter(entry);
		}
	}));
	
} finally {
	threadpool.shutdown();
}
	
printf('Set last to new dir: %s -> %s', lastDir, targetDir);
Files.deleteIfExists(lastDir);
Files.createSymbolicLink(lastDir, targetDir);
printf('Backup finished');
